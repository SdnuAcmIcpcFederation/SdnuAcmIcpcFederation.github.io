- ### KMP
  
  #### 概念
  
  KMP算法是一种**字符串匹配**算法，可以在 O(n+m) 的时间复杂度内实现两个字符串的匹配。
  
  **字符串匹配问题**
  
  所谓字符串匹配，是这样一种问题：“字符串 P 是否为字符串 S 的子串？如果是，它出现在 S 的哪些位置？” 其中 S 称为主串；P 称为模式串。
  
  ![img](images/17083616-9b40c67ea22e449f813fb38fcfd3a4fb.png)
  
  
  #### 原理
  
  KMP的重点就在于**当某一个字符与主串不匹配时，我们应该知道j指针要移动到哪**？**利用已经部分匹配这个有效信息，保持指针不回溯，通过修改j指针，让模式串尽量地移动到有效的位置**。
  
  当匹配失败时，j要移动的下一个位置k。存在着这样的性质：**最前面的个字符和之前的最后个字符是一样的**。
  
  ![img](images/17084056-66930855432b4357bafbf8d6c76c1840.png)
  
  弄明白了这个就应该可能明白为什么可以直接将j移动到k位置了。
  
  因为:
  
  **当T[i] != P[j]时**
  
  **有T[i-j ~ i-1] == P[0 ~ j-1]**
  
  **由P[0 ~ k-1] == P[j-k ~ j-1]**
  
  **必然：T[i-k ~ i-1] == P[0 ~ k-1]**
  
  如果分解成计算机的步骤，则是如下的过程：
  
  1. 找出前缀pre，设为pre[0~m]；
  
  2. 找出后缀post，设为post[0~n]；
  
  3. 从前缀pre里，先以最大长度的s[0~m]为子串，即设k初始值为m,跟post[n-m+1～n]进行比较：
  
  　　如果相同，则pre[0~m]则为最大重复子串，长度为m，则k=m;
  
  ​		如果不相同，则k=k-1;缩小前缀的子串一个字符，在跟后缀的子串按照尾巴对齐，进行比较，是否相同。
  
  ​		如此下去，直到找到重复子串，或者k没找到。
  
  **求next数组**
  
  好，接下来就是重点了，怎么求这个（这些）k呢？因为在P的每一个位置都可能发生不匹配，也就是说我们要计算每一个位置j对应的k，所以用一个数组next来保存，**next[j] = k，表示当T[i] != P[j]时，指针的下一个位置。另一个非常有用且恒等的定义，因为下标从0开始的，k值实际是j位前的子串的最大重复子串的长度。请时刻牢记next数组的定义，下面的解释是死死地围绕着这个定义来解释的。**
  
  next[j] 的值（也就是k）表示，当P[j] != T[i]时，j指针的下一步移动位置。
  
  先来看第一个：当j为0时，如果这时候不匹配，怎么办？
  
  ![img](images/17084258-efd2e95d3644427ebc0304ed3d7adefb.png)
  
  像上图这种情况，**j已经在最左边了，不可能再移动了，这时候要应该是i指针后移**。所以在代码中才会有next[0] = -1;这个初始化。
  
  如果是当j为1的时候呢？
  
  ![img](images/17084310-29f9f8dbb6034151a383e7ccf6f5583e.png)
  
  显然，**j指针一定是后移到0位置的**。因为它前面也就只有这一个位置了
  
  请仔细对比这两个图。
  
  我们发现一个规律：
  
  当P[k] == P[j]时，
  
  有next[j+1] == next[j] + 1
  
  其实这个是可以证明的：
  
  因为在P[j]之前已经有P[0 ~ k-1] == p[j-k ~ j-1]。（next[j] == k）
  
  这时候现有P[k] == P[j]，我们是不是可以得到P[0 ~ k-1] + P[k] == p[j-k ~ j-1] + P[j]。
  
  即：P[0 ~ k] == P[j-k ~ j]，即next[j+1] == k + 1 == next[j] + 1。
  
  原文说公式不好懂，看图容易。我觉得，公式实际挺简单的，结合图再把公式耐着性子看懂。实际上，该公式无非是用字母下标代表序列的起始段，描述了前缀和后缀重复相等的一段长度的序列罢了。
  
   
  
  那如果P[k] != P[j]呢？比如下图所示：
  
  ![img](images/17122358-fd7e52dd382c4268a8ff52b85bff465d.png)
  
  像这种情况，如果你从代码上看应该是这一句：k = next[k];为什么是这样子？你看下面应该就明白了。
  
  ![img](images/17122439-e349fed25e974e7886a27d18871ae48a.png)
  
  下面重点来了，请注意：我们看，在查找最大匹配的过程中，将上面选择的待比较的子串分成两部分：最后一个端点为一部分，前面的一段为一部分；比如上面的第一个选取的最大比较子串的例子：前缀的p[0~k-1]分成两段为p[0~k-2]和p[k-1],和后缀的p[j-k+1～j-1]和p[j]分别比较，即p[0~k-2]和p[j-k+1~j-1]比较，p[k-1]和p[j]比较，见图中的红色线段和绿色圆点；通过这个例子我们知道，只要前面一段能重复且尽可能的长，那么加上最后一个端点这个重复子串也必将是最长的。我们继续分析，因为next[j]已经求出，即p[0~k-1]===p[j-k~j-1],我们可以把上面的第一段的比较进一步转换成，比较p[0~k-2]和p[1~k-1]子串了，见图中紫线箭头指示的漂移；看到没有，这个就是求k位前的子串p[0~k-1]的最大重复子串，很显然不就是求next[k]嘛？！很明显p[0~next[k]-1]就是我们要找的第一个候选最大的重复子串，这也说明了子串p[0~k-2]就不可能是重复子串，也没有尝试比较的必要。因为根据next[j]的定义我们知道，next[k]就是要求的子串为p[0~k-1]的最大重复子串的长度，最大，最大，最大，重要的事说三遍。我们是充分利用了前面k<j时，next[k]已经求出来的条件，减少了子串比较的次数(其实也不叫减少了，那些比较本来就是无效的)；这解释了为什么把k=next[k]。此时，p[0~next[k]-1]和p[j-next[k]~j-1]子串已经恒等了，我们只要比较另外的一部分即两个端点，p[next[k]]和p[j](对应于代码中的p[k]==p[j]，注意在上个循环p[k]!=p[j]时，k已经被赋值next[k],而j还是上次的那个j);如果这两者相等了,则重复子串的长度+1，next[j+1]=next[k]+1(k++即next[k]+1);如果不相等了，则说明倒数第二大的p[0~next[k]-1]都不行了，比这个重复子串小的最大的重复子串只能是k=next[next[k]]了，如此继续查找下去。因此比较的都是按序递减的最大重复子串，非常的有效，一点都没有多比较。找不到的话，k会被赋值为-1。
  
  #### 实现
  
  next:
  
  ```cpp
  int ne[100];///这个数组中盛放的是匹配字符串的next值
  void GetNext(char *a)///这个函数是为了标记匹配字符串的next值
  {
       int len = strlen(a);///先求字符串的长度，便于循环赋值
       int i = 0, j = -1;
       ne[0] = -1;
       while(i < len)
       {
            if(j == -1 || a[i] == a[j])
            {
                 ne[++i] = ++j;
            }
            else j = ne[j];
       }
  }
  ///实际上每求一个next值要循环两遍
  ```
  
  kmp:
  
  ```cpp
  int KMP(char *a, char *b)
  {
       int lena = strlen(a);
       int lenb = strlen(b);
       int i = 0, j = 0;
       while (i < lena && j < lenb)
       {
            if(j == -1 || a[i] == b[j])
            {
                 j++;
                 i++;
            }
            else
                 j = ne[j];
       }
       if(j == lenb)
            return i-j+1;
       else
            return -1;
  }
  ```
  
  
  
  ### 